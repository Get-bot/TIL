## 1. 람다식이란?
함수형 프로그래밍이란 함수를 정의하고 이 함수를 데이터 처리부로 보내 데이터를 처리하는 기법을 말한다. 데이터 처리부는 데이터만 가지고 있을 뿐, 처리 방법이 정해져 있지 않아 외부에서 제공된 함수에 의존한다.

![](https://velog.velcdn.com/images/co-vol/post/ce76b037-d3f9-4988-a528-8bb4d180f880/image.png)
데이터 처리부는 제공된 함수의 입력값으로 데이터를 넣고 함수에 정의된 처리 내용을 실행한다. 동일한 데이터라도 함수A를 제공해서 처리하는 결과와 함수B를 제공해서 처리하는 결과는 다를 수 있따. 이것이 함수형 프로그래밍의 특징으로, 데이터 처리의 다형성이라고도 볼 수 있다.

자바는 함수형 프로그래밍을 위해 Java 8부터 람다식을 지원한다. 람다식은 위 그림과 같이 데이터 처리부에 제공되는 함수 역할을 하는 매개변수를 가진 중괄호 블록이다. 데이터 처리부는 람다식을 받아 매개변수에 데이터를 대입하고 중괄호를 실행시켜 처리한다.
```java
람다식: (매개변수, ...) -> { 처리 내용 }
```
자바는 람다식을 익명 구현 객체로 변환한다. 익명 구현 객체란 이름이 없는 인터페이스 구현 객체를 말한다.
```java
public interface Calculable {
	//추상 메소드
    void calculate(int x, int y);
}
```
Calculable 인터페이스의 익명 구현 객체는 다음과 같이 생성할 수 있다.
```java
new Calculable() {
	@Ovveride
    public void claculate(int x, int y) { 처리내용 }
}
```
이것을 람다식으로 표현하면 다음과 같다. 추상 메소드인 calculate()는 두 개의 매개변수를 가지므로 (x, y)로 표현되었고, 화살표 -> 뒤에 calculate()의 실행 블록이 온다.
```java
new Calculable((x, y) -> { 처리내용 })
```
람다식은 인터페이스의 익명 구현 객체이므로 인터페이스 타입의 매개변수에 대입될 수 있다. 예를 들어 다음과 같이 Calculable 매개변수를 가지고 있는 action() 메소드가 있다고 가정해보자.
```java
public void action(Calculable calculable) {
	int x = 10;
    int y = 4;
    calculable.calculate(x, y);
}
```
action() 메소드를 호출할 때 매개값으로 람다식을 제공할 수 있다. action() 메소드 에서 calculable.calculate(x, y)를 실행하면 람다식의 중괄호 블록이 실행되면서 데이터가 처리된다. 여기서 action() 메소드는 제공된 람다식을 이용해서 내부 데이터를 처리하는 처리부 역할을 한다.
```java
action((x, y) -> {
 int result = x + y;
 System.out.println(result);
});
```
다음 그림과 같이 람다식1과 람다식2 중에서 어떤 람다식을 매개값으로 제공하느냐에 따라 계산 결과는 달라질 수 있다.
![](https://velog.velcdn.com/images/co-vol/post/0b8b14cf-4e3c-48a3-853e-95301b22d8dc/image.png)
인터페이스의 익명 구현 객체를 람다식으로 표현하려면 인터페이스가 단 하나의 추상 메소드만 가져야 한다. 따라서 다음과 같이 두 개 이상의 추상 메소드를 가진 RemoteContorl 인터페이스는 람다식으로 표현할 수 없다.
```java
public interface RemotControl {
	void turnOn();
    void turnOff();
}
```
인터페이스가 단 하나의 추상 메소드를 가질 때, 이를 함수형 인터페이스라고 한다.
![](https://velog.velcdn.com/images/co-vol/post/ec514316-66e8-4085-a59d-e59cb8c22dba/image.png)
인터페이스가 함수형 인터페이스임을 보장하기 위해서는 @FunctionalInterface 어노테이션을 붙이면 된다. @FunctionalInterface를 붙이는 것은 선택사항이지만. 컴파일 과정에서 추상 메소드가 하나인지 검사하기 때문에 정확한 함수형 인터페이스를 작성할 수 있게 도와주는 역할을 한다.
## 2. 매개변수가 없는 람다식
함수형 인터페이스의 추상 메소드에 매개변수가 없을 경우 람다식은 다음과 같이 작성할 수 있다. 실행문이 두 개 이상일 경우에는 중괄호를 생략할 수 없고, 하나일 경우에만 생략할 수 있다.
```java
//실행문이 하나가 아닐 경우
() => {
	실행문
    실행문
}
// 실행문이 하나일 경우
() -> 실행문
```
## 3. 매개변수가 있는 람다식
함수형 인터페이스의 추상 메소드에 매개변수가 있을 경우 람다식은 다음과 같이 작성할 수 있다. 매개변수를 선언할 때 타입은 생략할 수 있고, 구체적인 타입 대신에 var를 사용할 수도 있다. 하지만 타입을 생략하고 작성하는 것이 일반적이다.
![](https://velog.velcdn.com/images/co-vol/post/fef19d3d-ee1d-4f2f-a422-a25f31095849/image.png)
매개변수가 하나일 경우에는 괄호를 생략할 수도 있다. 이때는 타입 또는 var를 붙일 수 없다.
![](https://velog.velcdn.com/images/co-vol/post/73630d5b-5d19-4e2f-a20b-c02a5310c1b8/image.png)

## 4. 리턴값이 있는 람다식
함수형 인터페이스의 추상 메소드에 리턴값이 있을 경우 람다식은 다음과 같이 작성할 수 있다.
return 문 하나만 있을 경우에는 중괄호와 함께 return 키워드를 생략할 수 있다. 리턴값은 연산식 또는 리턴값 있는 메소드 호출로 대체할 수 있다.
![](https://velog.velcdn.com/images/co-vol/post/7f0d470d-5141-42d2-861e-63dcf3597012/image.png)

## 5. 메소드 참조
메소드 참조는 말 그대로 메소드를 참조해서 매개변수의 정보 및 리턴 타입을 알아내 람다식에 불필요한 매개변수를 제거하는 것을 목적으로 한다. 예를 들어 두 개의 값을 받아 큰 수를 리턴하는 Math클래스의 max() 정적 메소드를 호출하는 람다식은 다음과 같다.
```java
(left, right) -> Math.max(left, right);
```
람다식은 단순히 두 개의 값을 Math.max() 메소드의 매개값으로 전달하는 역할만 하기 때문에 다소 불편해 보인다. 이 경우에는 다음과 같이 메소드 참조를 이용하면 깔끔하게 처리할 수 있다.
```java
Math::max;
```
### 1. 정적 메소드와 인스턴스 메소드 참조
정적 메소드를 참조할 경우에는 클래스 이름 뒤에 `::` 기호를 붙이고 정적 메소드 이름을 기술한다.
```java
클래스::메소드
```
인스턴스 메소드일 경우에는 먼저 객체를 생성한 다음 참조 변수 뒤에 `::` 기호를 붙이고 인스턴스 메소드 이름을 기술한다.
```java
참조변수::메소드
```

### 2. 매개변수의 메소드 참조
다음과 같이 람다식에서 제공되는 a 매개변수의 메소드를 호출해서 b 매개변수를 매개값으로 사용하는 경우도 있다.
```java
(a, b) -> {a.instanceMethod(b);}
```
이것을 메소드 참조로 표현하면 다음과 같다. a의 클래스 이름 뒤에 :: 기호를 붙이고 메소드 이름은 기술한다. 작성 방법은 정적 메소드 참조와 동일하지만, a의 인스턴스 메소드가 사용된다는 점에서 다르다.
```java
클래스 :: instanceMethod
```
## 6. 생성자 참조
생성자를 참조한다는 것은 객체를 생성하는 것을 의미한다. 람다식이 단순히 객체를 생성하고 리턴하도록 구성된다면 람다식을 생성자 참조로 대치할 수 있다. 다음 코드를 보면 람다식은 단순히 객체를 생성한 후 리턴만 한다.
```java
(a, b) -> { return new 클래스(a, b); }
```
이것은 생성자 참조로 표현하면 다음과 같다. 클래스 이름 뒤에 `::` 기호를 붙이고 new 연산자를 기술하면 된다.
```java
클래스 :: new
```
생성자가 오버로딩되어 여러 개가 있을 경우, 컴파일러는 함수형 인터페이스의 추상 메소드와 동일한 매개변수 타입과 개수를 가지고 있는 생성자를 찾아 실행한다. 만약 해당 생성자가 존재하지 않으면 컴파일 오류가 발생한다.