# 삽입 정렬(Insertion Sort)

### 개요

- 손 안의 카드를 정렬하는 방법과 유사
- Selection Sort와 유사하지만, 좀 더 효율적인 정렬 알고리즘이다.
- **2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입 하여 정렬하는 알고리즘**
- 최선의 경우 O(n)이라는 효율성을 가지고 있어, 다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬 알고리즘이다.

### 프로세스(오름차순)

1. 정렬은 2번째 위치(index)값을 temp에 저장한다.
2. temp와 이전에 있는 원소들과 비교하며 삽입해나간다.
3. 1번으로 돌아가 다음 위치(index)값을 temp에 저장하고, 반복한다.

### Java Code

```java
void insertionSort(int[] arr) {
	for(int i = 1; i < arr.length; i++ { // 1.
		int temp = arr[i];
		int prev = i - 1;
		while( prev >= 0 && arr[prev] > temp) { // 2.
			arr[prev + 1] = arr[prev];
			prev--;
		}
		arr[prev + 1] = temp; // 3.
	}
}
```

1. 첫 번째 원소 앞(왼쪽)에는 어떤 원소도 갖고 있지 않기 때문에, 두 번째 위치부터 탐색을 시작한다. temp에 임시로 해당 위치(index) 값을 저장하고, prev에는 해당 위치의 이전 위치를 저장한다.
2. 이전 위치를 가리키는 prev가 음수가 되지않고, 이전 위치(index)의 값이 1번에서 선택한 값보다 크다면, 서로 값을 교환해주고 prev를 더 이전 위치를 가리키도록 한다.
3. 2번 에서 반복문이 끝나고 난 뒤, prev에는 현재 temp 값보다 작은 값들 중 제일 큰값의 위치를 가리키게 된다. 따라서 prev + 1에 temp값을 삽입해준다.

### 시간 복잡도

- 최악의 경우(역으로 정렬되어 있을 경우) Selection Sort와 마찬가지로, **O(n^2)**이다.
- 모두 정렬되어 있는 경우, 한번씩 밖에 비교를 안하므로 **O(n)** 이다.
- 이미 정렬되어 있는 배열에 자료를 하나씩 삽입/제거 하는 경우에는, 현실적으로 최고의 정렬 알고리즘에 된다, 탐색을 제외한 오버헤드가 매우 적기 때문이다.
- 최선의 경우 **O(n)**을 가지며 최악,평균의 경우 **O(n^2)**를 가진다.

### 공간 복잡도

- 주어진 배열 안에서 교환을 통해, 정렬이 숭행되므로 O(n)이다.

### 장점

- 알고리즘이 단순
- 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
- 제자리 정렬로 다른 메모리 공간을 필요로 하지 않는다.
- 안전 정렬이다.
- Selection Sort, Bubble Sort(O(n^2))에 비해 상대적으로 빠르다.

### 단점

- 평균과 최악의 시간복잡도가 O(n^2)이다.
- 배열의 길이가 길어질수록 비효율적이다.

### Selection Sort 와의 차이점

Selection Sort과 Insertion Sort는 k번째 반복 이후, 첫 번째 요소가 정렬된 수서로 온다는 점에서 유사하다. Selection Sort는  k+1번째 요소를 찾기 위해  나머지 모든 요소들을 탐색하지만 Insertion Sort는 k+1번째 요소를 배치하는 데 필요한 만큼의 요소만 탐색하기 때문에 훨씬 효율적으로 실행된다는 차이가 있다.