# 시간 복잡도

생성자: 범진 최
생성 일시: 2024년 1월 16일 오후 5:03
태그: 알고리즘

컴퓨터가 계산할 때 사용하는 알고리즘,함수에 따라 값에 증가에 따른 결괏값을 구하는 시간이 달라지는데 이를 시간 복잡도라고 얘기한다.

### O(Big O) 표기법

- 빅 O 표기법은 최악의 경우 알고리즘 수행 시간을 나타낸다. 즉 **알고리즘을 사용하는 어떤 경우에도 보장되는 알고리즘의 성능**이라고 할 수 있다.
- 최악의 경우에 대한 알고리즘 수행 시간이 가장 쓸모가 많다 보니 가장 많이 사용하는 알고리즘 성능 표기법이다.
- 대문자 O를 쓰고 그 옆에 괄호에 증가 함수를 넣는다. 증가 함수는 입력 데이터의 크기 n에 대해 알고리즘의 수행 시간이 늘어나는 비율을 나타내는 함수이다.

### 빅 O 표기법에서 널리 사용되는 규모 함수들의 최선 → 최악 순서

**상수 시간 → 로그 시간 → 선형 시간 → 선형로그 시간 → 2차 시간 → 3차 시간 → 지수 시간**

![20231031162644_hrtgflzn.png](img0231031162644_hrtgflzn.png)

![img1.daumcdn.png](imgmg1.daumcdn.png)

### 상수 시간

- 가장 효율적인 규모는 상수 시간 복잡도(Constant Time Complexity)이다.
- 어떤 알고리즘이 n의 크기에 관계없이 동일한 단계만 필요한 경우 ‘알고리즘이 상수 시간으로 실행된다.’ 고 말한다.
- **O(1)** 이라고 표기한다.
- 예시

  온라인 서점을 운영하며 매일 첫 번째로 방문하는 고객에게 무료로 책을 선물한다고 가정하고 이 고객을 customers 리스트에 저장한다고 하면

    ```java
    freeBooks = customers[0]
    ```

  이 알고리즘의 단계를 나타내는 수식 T(n)은 다음과 같다.

    ```java
    T(n) = 1
    ```

  고객이 아무리 많아도 이 알고리즘에는 하나의 단계만 필요하다. 고객이 1000명, 10000명이더라도 한 단계로 끝나고, 조단위라 하더라도 한 단계면 충분하다. 고객의 수를 x축 알고리즘의 단계를 y축으로 하는 상수 시간 복잡도 그래프를 그리면 평평한 상태가 된다.

  ![20231031164759_przbklgs.png](img0231031164759_przbklgs.png)

  상수 시간 알고리즘은 그림과 같이 알고리즘이 완료될 때까지 필요한 단계가 일정하다. 데이터 세트가 아무리 커지더라도 알고리즘의 실행시간이 변하지 않으므로 가장 효율적인 알고리즘이라고 할 수 있다.


### 로그시간

- 로그 시간 복잡도(Logarithmic Time Complexity)는 상수 시간에 이어 두 번째로 효율적인 시간 복잡도이다.
- 데이터의 로그에 비례해 알고리즘의 단계가 늘어날 때, 알고리즘이 로그 시간으로 실행된다고 말한다.
- 로그 시간 복잡도는 실행을 반복할 때마다 알고리즘의 탐색 범위를 1/2로 줄여 나가는 이진 탐색과 같은 알로리즘에서 볼 수 있다.
- O(log n) 으로 표기한다.

![20231031165427_sksekrex.png](img0231031165427_sksekrex.png)

- 로그 시간 알고리즘은 데이터 세트가 커짐에 따라 알고리즘의 실행에 필요한 단계가 천천히 늘어나는 알고리즘을 말한다.

### 선형 시간

- 로그 시간 복잡도 다음으로 효율적인 것은 선형 시간 복잡도(Linear Time Complexity)이다.
- 선형 시간으로 실행되는 알고리즘은 데이터의 크기가 커지는 만큼 같은 비율로 단계가 늘어나는 알고리즘을 말한다.
- O(n)으로 표기한다.
- 예시

  매일 첫 번째로 방문하는 고객에게 무료로 책을 선물하는 대신, 고객 리스트를 훑어 보면서 이름이 B로 작하는 고객에게 책을 선물한다고 가정해보자. 고객 리스트가 알파벳 순으로 정렬되어 있지 않다면 B로 시작하는 이름을 하나씩 탐색하여 찾아야 한다.

    ```java
    Boolean freeBook = False;
    String[] customers ={"A", "B", "B", "C", "B"};
    for(String customer: customers ) {
    	if (customer == "B") System.out.println(customer);
    }
    ```

  고객이 다섯 명이라면 프래그램도 이름을 탐색하는 다섯 번의 단계를 거쳐야 한다. 고객이 10명이면 10번 n명이면 n번의 탐색 단계가 필요하다. 따라서 이 프로그램의 시간 복잡도는 각각 feeeBook과 customers에 할당하는 단계와 고객 리스트에서 B로 시작하는 이름을 탐색하는 n번의 단계를 더해 다음과 같이 나타낼 수 있다.

    ```java
    f(n) = 1 + 1 + n
    ```

  빅 O 표기법에서는 상수 부분을 무시하고 f(n)을 지배하는 부분만 선택해 다음과 같이 나타낸다.

    ```java
    O(n) = n
    ```

  ![20231031165727_ucspegwq.png](img0231031165727_ucspegwq.png)


### 선형 로그 시간

- 선형 로그 시간(Log-Linear Time)을 따르는 알고리즘의 복자도는 로그 시간 복잡도와 선형 시간 복잡도를 곱한 만큼 커진다.
- 로그 시간으로 실행되는 알고리즘을 O(log n)을 n 번 반복하는 형태를 말한다.
- O(n log n)으로 표기한다.
- 선형 로그 시간 알고리즘은 보통 데이터 세트를 작은 부분으로 나누고, 이들을 독립적으로 처리하는 형태를 취한다.
- 병합 정렬과 같은 효율적인 정렬 알고리즘은 대부분 선형 로그 시간 복잡도를 따른다.

![20231031165809_mkuypmpm.png](img0231031165809_mkuypmpm.png)

- 선형 로그 시간 복잡도는 선형 시간 복잡도보다는 비효율적이지만, 2차 시간 복잡도보다는 효율적이다

### 2차 시간

- 2차 시간 복잡도(Quadratic Time Complexity)는 선형 로그 시간 복잡도 다음으로 효율적인 시간 복잡도이다.
- 2차 시간으로 실행되는 알고리즘의 복잡도는 n의 제곱의 정비레하며,
- O(n^2)로 표기한다.
- 예제

    ```java
    int[] numbers = {1, 2, 3, 4, 5};
    for(int number : numbers) {
    	for(int number2 : numbers) {
    		System.out.println(number * number2);	
    	}
    }
    ```

  이 알고리즘은 숫자 리스트 numbers에 들어있는 모든 숫자를 서로 곱해 변수에 저장한 후 출련한다.

  여기서 n은 numbers 리스트의 크기이므로, 이 알고리즘의 시간 복잡도 f(n)은 다음과 같이 나타낼 수 있다.

    ```java
    f(n) = 1 + n * n * (1 + 1)
    ```

  이 식의 (1 + 1) 부분은 각각 (number * number2)를 변수 x에 저장하는 단계와 print함수에 해당한다.

  두 번 중첩된 for 루프를 통해 곱셈과 출력을 n * n번 반복한다 f(n)은 다음과 같이 단수화 가능하다.

    ```java
    f(n) = 1 + (1 + 1) * n^2
    
    f(n) = 1 + 2 * n^2
    ```

  마찬가지로 f(n)의 크기를 지배하는 부분이 n^2 이므로 빅O표기법으로 다음과 같이 나타낼 수 있다.

    ```java
    O(n) = n^2
    ```

- 2차 시간 복잡도를 그래프로 그려보면 알고리즘 1부터 n까지 또는 0부터 n-1 까지 실행하는 루프가 두 번 중첩되어 있다면 그 알고리즘의 시간 복잡도는 최소한 O(n^2)이상이다.
- n의 제곱에 비례해 실행 시간이 늘어나는 삽입 정렬이다 버블 정렬과 같은 정렬 알고리즘의 상당수가 2차 시간 복잡도를 따른다.

  ![20231031170233_tebilllz.png](img0231031170233_tebilllz.png)


### 3차 시간

- 3차 시간(Cubic Tiem)으로 실행되는 알고리즘의 시간 복잡도는 n의 세제곱에 정비례한다.
- O(n^3)으로 표기한다.
- 예시

    ```java
    int[] numbers = {1, 2, 3, 4, 5};
    for(int number : numbers) {
    	for(int number2 : numbers) {
    		for(int number3 : numbers) {
    			System.out.println(number * number2 * number3);	
    		}
    	}
    }
    ```


- 2차와 3차 시간 복잡도는 모두 다항 시간 복잡도에 속한다.
- 다항 시간 복잡도(Polynomial Time Complexity)를 따르는 알고리즘은 O(n^a)에 비례하여 커지는데 2차 시간은 a가 2 3차시간은 a가3 인 경우에 해당한다. 알고리즘을 설계할 때는 가급적 다항 시간 알고리즘을 피하는 편이 좋으며, 이런 알고리즘은 n이 커짐에 따라 알고리즘의 실행 시간이 급격하게 늘어날 수 있기 때문이다.

### 지수 시간

- 최악의 시간 복잡도로 꼽히는 것은 지수 시간 복잡도(Exponential Time Complexity)이다.
- 지수 시간으로 실행되는 알고리즘의 복잡도는 데이터 크기의 지수식으로 표현된다.
- 어떤 상수 c를 n제곱한 만큼 실행 단계가 커지는 알고리즘으로
- O(c^n)으로표기한다
- 예제

    ```java
    int pin = 931;
    int pinLength = pin.length();
    for(int i = 0; i < 10**pinLength) i++) {
    	if (i == pin) System.out.println(i);
    }
    ```

  이 알고리즘을 완료하기 위해 필요한 단계는 n이 커짐에 따라 믿을 수 없을 정도로 빠르게 커진다. n 이 1이면 10번이지만 n이3이면 1000번의 단계가 필요하다.

  언뜻 보기에는 지수 시간 알고리즘이 그렇게까지 빨리 커지는 것처럼 보이지 않지만 감당할 수 없이 커지는 건 순식간이다.

  여덟 자리의 비밀번호를 알아내려면 1억 번을 시도해야 하고, 열 자리의 비밀번호를 알아내려면 100억 번을 시도해야 한다.

  이런 식으로 비밀번호를 알아내는 것을 무차별 대입 알고리즘(Brute-Force Alogorithm)이라고 한다. 무차별 대입 알고리즘은 가능한 경우의 수를 전부 대입해 보는 알고리즘으로 보통 이 알고리즘은 최후의 수단으로만 사용해야 한다.


### 최선과 최악

- 알고리즘의 실행 시간. 즉 성능은 데이터의 종류를 비롯해 다양한 요인에 의해 변화한다.
- **알고리즘의 성능을 평가할 때는 최선과 최악, 평균의 시간 복잡도를 고려해야 한다.**
- 최선의 경우 시간 복잡도는 알고리즘에 입력되는 데이터가 이상적이 때, 최악의 경우인 시간 복잡도는 말 그대로 가능한 모든 시나리오 중 가장 최악(알고리즘의 실행 시간이 급격하게 커지는/느렺지는 경우)일 때, 평균의 경우시간 복잡도는 알고리즘이 평균적으로 얼마나 빨리 실행되는지를 나타낸다.
- 예를들어 리스트의 요소를 하나씩 탐색한다고 할 때, 정말 운이 좋다면 탐색을 시작하자마자 첫 번째 항목에서 원하는 요소를 찾을 수도 있다. 이것이 바로 최선의 경우에 해당하는 시간 복잡도이다. 반면에 찾으려는 요소가 리스트에 없다면 리스트 전체를 탐색해야 하는 최악의 경우에 해당하는 시간 복잡도가 된다.
- 리스트에 대한 순차 탐색을 100차례 수행한다고 하면 평균적으로 O(n/2)의 시간 안에 탐색이 끝난다. 여기에서 O(n/2)은 빅 O 표기법을 통해 O(n)으로 표기할 수 있다. 일반적으로 알고리즘을 비교할 때는 평균의 시간 복잡도부터 살펴본다. 만약 더 깊이 분석하고 싶다면 최선과 최악의 경우인 시간 복잡도를 비교해 볼 수 있다.

### 공간 복잡도

알고리즘의 효율을 생각할 때는 컴퓨터의 메모리도 유한한 자원이므로 시간 복잡도뿐만 아니라 자원을 얼마나 사용하는지도 고려해야 한다.

- **공간 복잡도(Space Complexity)는 알고리즘의 실행을 완료할 때까지 필요한 자원의 양, 즉 고정 공간, 데이터 구조 공간, 임시 공간의 메모리를 얼마나 사용 하는지 나타낸다.**
- 고정 공간(Fixed Space)은 프로그램 자체가 차지하는 메모리를 말하며, 자료구조 공간(Data Structure Space)은 데이터 세트 , 예를 들어 탐색의 대상이 되는 리스트를 저장하는 데 필요한 메모리를 말한다. 알고리즘에서 이 데이터를 저장하기 위해 사용하는 메모리는 n의 크기에 따라 달라진다.
- 임시 공간(Temporary Space)은 알고리즘에서 중간 처리를 위해 사용하는 메모리, 예를 들어 데이터 전송을 위해 임시로 리스트 사본을 만들 때 필요한 메모리를 말한다.
- 시간 복잡도의 개념을 공간 복잡도에 적용
    - n의 팩토리얼(n 이하의 양의 정수를 모두 곱한 값)을 계산하는 알고리즘은 상수 공간 복잡도인 O(1)을 따른다

    ```java
    int x = 1;
    int n = 5;
    for(int i = 1; i <= 5; i++) {
    	x *= i
    }
    ```

    - 이 알고리즘의 공간 복잡도가 상수인 이유는 n이 커져도 알고리즘에서 추가로 메모리를 사용하지 않기 때문이다.
    - 반면에 n까지 도달하면서 계산한 중간 결과를 모두 리스트에 저장한다면 선형 공간 복잡도O(n)을 따르게 된다.

### 복잡도의 중요성

컴퓨터 과학자가 알고리즘을 최적화하기 위해서는 먼저 규모에 대해 이해해야 한다. 알고리즘을 개선하고 싶다면 규모를 줄일 방안을 모색해야 한다. 예를 들어 for 루프가 두 번 중첩된 O(n^2)알고리즘이 있다고 하자 이 알고리즘을 최적하하기 위해 루프의 내부를 검토하는 것은 생각보다 중요하지 않다. 중첩된 for루프를 사용하지 않을 수 있는지, 다시 말해 알고리즘의 규모를 줄일 수 있는지 판단하는 일이 훨씬 더 중요하다.

같은 문제를 중첩되지 않는 두 개의 for 루프를 쓰는 알고리즘으로 풀 수 있다면 이 알고리즘의 시간 복잡도는  O(n)이 되고, 두 경우의 성능은 크게 차이나게 된다. O(n^2)인 알고리즘을 조정하여 아무리 효율을 올린다고 해도 O(n)으로 고쳐 쓰는 것에는 비교할 수 없다. 하지만 알고리즘의 최선 또는 최악의 경우를 고려하는 것도 중요하다. 피치 못하게 O(n^2)인 알고리즘을 사용한다고 하더라도 최선의 경우에는 O(n)과 같은 결과를 낼 수 있고, 최선의 경우에 해당하는 데이터 일 수 있다. 만약 이런 경우라면 O(n^2)인 알고리즘도 좋은 선택일 수 있다.

알고리즘을 잘 선택하는 것은 실제로 큰 영향을 미친다. 예를 들어 사용자의 요청에 따라 알고리즘을 작성할 책임이 있다고 하면. 상수 시간 알고리즘을 선택하는지, 2차 시간 알고리즘을 선택하는지에 따라 큰 차이가 발생할 수 있다.