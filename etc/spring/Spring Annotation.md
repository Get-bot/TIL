# Spring Annotation
### **1. @Configuration**

스프링 설정 파일을 나타내며, 빈 정의 및 의존성 주입 설정을 담고 있는 클래스에 사용됩니다. 이 애노테이션이 붙은 클래스 내부에서 @Bean 애노테이션을 사용하여 빈을 정의할 수 있습니다.

### **2. @ComponentScan**

지정된 패키지와 그 하위 패키지에서 @Component 애노테이션이 붙은 클래스를 찾아 스프링 빈으로 등록합니다. @Configuration 클래스와 함께 사용되며, 스프링이 자동으로 클래스를 찾아 빈으로 등록하게 합니다.

### **3. @Bean**

개발자가 직접 제어할 수 없는 외부 라이브러리를 스프링 빈으로 등록하고 싶을 때 사용합니다. @Configuration 애노테이션이 붙은 클래스 내의 메서드에 사용되며, 메서드가 반환하는 객체를 빈으로 등록합니다.

### **4. @PostConstruct & @PreDestroy**

@PostConstruct는 빈의 초기화 작업을 위해 사용되며, 빈이 생성되고 의존성이 주입된 후에 자동으로 호출됩니다. 반면, @PreDestroy는 빈이 소멸되기 전에 필요한 작업을 위해 사용되며, 소멸 과정에서 자동으로 호출됩니다.

### **5. @Component, @Service, @Controller, @Repository**

이들 애노테이션은 스프링의 다양한 계층(컴포넌트, 서비스, 컨트롤러, 데이터 접근 계층)에서 클래스를 빈으로 등록할 때 사용됩니다. 각각의 애노테이션은 스프링이 클래스의 역할을 명확히 이해하는 데 도움을 줍니다.

### **6. @Autowired**

의존성 주입을 위해 사용되며, 스프링이 자동으로 의존성을 주입하게 합니다. 생성자, 필드, 세터 메서드에 사용할 수 있습니다.

### **7. @Primary vs @Qualifier**

@Autowired를 사용하여 의존성을 주입할 때, 동일한 타입의 빈이 여러 개 있을 경우 선택해야 하는 상황이 발생할 수 있습니다. @Primary는 이러한 상황에서 스프링이 우선적으로 선택해야 할 빈을 지정합니다. 반면, @Qualifier는 자동 주입할 빈을 더 세밀하게 지정할 수 있게 해주며, 특정 빈의 이름을 직접 지정할 때 사용됩니다.

### **8. @Lazy**

이 애노테이션은 빈의 생성을 실제로 필요로 할 때까지 지연시키는 기능을 제공합니다. 기본적으로 스프링은 애플리케이션 시작 시점에 모든 싱글톤 빈을 생성하고 초기화하지만, @Lazy 애노테이션을 사용하면, 빈이 실제로 필요한 순간까지 생성을 지연시킬 수 있습니다.

### **8-1. 지연 초기화(Lazy Initialization) vs 즉시 초기화(Eager Initialization)**

- **지연 초기화(Lazy Initialization)**: @Lazy 애노테이션을 통해 빈의 생성을 그 사용 시점까지 지연시킬 수 있습니다. 이 방식은 자원을 효율적으로 사용하고, 애플리케이션의 시작 시간을 단축시킬 수 있습니다. 특히, 애플리케이션 시작 시점에 바로 필요하지 않은 무거운 빈들에 유용합니다.
- **즉시 초기화(Eager Initialization)**: 스프링은 기본적으로 싱글톤 스코프 빈을 애플리케이션 시작 시 모두 생성하고 초기화합니다. 이는 애플리케이션의 응답성을 높이기 위해 필요한 경우가 많지만, 불필요한 자원 사용이나 시작 시간 지연을 초래할 수 있습니다.
 
| 구분 | 지연 초기화(Lazy Initialization) | 즉시 초기화(Eager Initialization) |
  | --- | --- | --- |
  | 초기화 시점 | 애플리케이션에서 처음 사용될 때 빈이 초기화됨 | 애플리케이션 시작 시 모든 빈이 초기화됨 |
  | 기본값 | 기본값 아님 | 기본값 |
  | 코드 스니펫 | @Lazy OR @Lazy(value=true) | @Lazy(value=false) OR (@Lazy 없음) |
  | 초기화 중 오류 발생 시 처리 | 런타임 예외로 결과됨 | 애플리케이션이 시작되지 않 |
  | 사용 빈도 | 드물게 사용됨 | 매우 자주 사용됨 |
  | 메모리 소비 | 적음 (빈이 초기화될 때까지) | 시작 시 모든 빈이 초기화되므로 소비량이 많음 |
  | 추천 시나리오 | 앱에서 매우 드물게 사용되는 빈 | 대부분의 빈 |
### **9. @Scope**

이 애노테이션은 빈의 스코프를 지정하는 데 사용됩니다. @Scope 애노테이션에 싱글톤, 프로토타입 등의 값을 지정함으로써 해당 빈의 생명주기를 관리할 수 있습니다. 특정 스코프가 지정되지 않은 경우, 스프링은 기본적으로 싱글톤 스코프를 사용합니다

### **9-1. 싱글톤(Singleton) vs 프로토타입(Prototype)**

- **싱글톤(Singleton)**: 이 스코프는 기본 스코프로, 스프링 컨테이너 내에 단 하나의 빈 인스턴스만을 생성합니다. 모든 요청에서 동일한 인스턴스를 공유하게 됩니다. 대부분의 경우, 애플리케이션 내에서 공유되는 설정이나 서비스 등에 적합합니다.
- **프로토타입(Prototype)**: 이 스코프를 사용하면 빈을 필요로 할 때마다 새로운 인스턴스가 생성됩니다. 따라서 각각의 빈 요청은 고유한 인스턴스를 받게 됩니다. 사용자의 요청 또는 작업마다 별도의 빈 인스턴스가 필요할 때 유용합니다.


## **10. @Component vs @Bean**

- **@Component**: 주로 개발자가 정의한 클래스를 스프링 빈으로 등록할 때 사용됩니다. 클래스 레벨에 붙이며, 스프링이 자동으로 빈을 검색하고 생성합니다.
- **@Bean**: 메서드 레벨에 사용되며, 주로 외부 라이브러리나 설정을 통해 빈을 생성할 때 사용됩니다. @Configuration 클래스 내의 메서드에 붙여 사용하며, 이 메서드가 반환하는 객체를 스프링 컨테이너가 관리하는 빈으로 등록합니다

| 구분                              | @Component | @Bean |
|---------------------------------| --- | --- |
| 사용되는 곳                          | 어떤 자바 클래스에나 사용될 수 있음 | 주로 스프링 구성(Configuration) 클래스의 메소드에서 사용됨 |
| 사용의 용이성                         | 매우 쉬움. 단지 어노테이션을 추가하기만 하면 됨. | 모든 코드를 직접 작성함. |
| 자동 연결(Autowiring)               | 예 - 필드, 세터 또는 생성자 주입 가능 | 예 - 메소드 호출 또는 메소드 파라미터를 통해 가능 |
| 빈 생성자                           | 스프링 프레임워크가 생성 | 빈 생성 코드를 직접 작성함 |
| 추천되는 경우                         | 자신의 애플리케이션 코드에 대한 빈 인스턴스화: @Component | 1: 사용자 정의 비즈니스 로직
 2: 제3자 라이브러리에 대한 빈 인스턴스화: @Bean |
| 클래스당 빈의 수                       | 하나 (싱글톤) 또는 여러 개 (프로토타입) | 하나 또는 여러 개 - 원하는 만큼 생성 가능 |